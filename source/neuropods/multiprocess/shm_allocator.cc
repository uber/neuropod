//
// Uber, Inc. (c) 2019
//

#include "neuropods/multiprocess/shm_allocator.hh"

#include "neuropods/internal/error_utils.hh"
#include "neuropods/internal/memory_utils.hh"

#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/sync/interprocess_mutex.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>

#include <mutex>
#include <unordered_map>

namespace neuropods
{

namespace
{

namespace ipc = boost::interprocess;

// A struct stored in shared memory that contains the data and a cross process refcount
struct __attribute__((__packed__)) shm_block
{
    // This mutex is used to synchronize operations on the metadata below
    ipc::interprocess_mutex mutex;

    // Note: this refcount is only the number of processes that have a pointer
    // to this data. Not the total number of active pointers.
    // This is okay because we're using `shared_ptr<shm_block>` in each process
    size_t process_refcount = 0;

    // Blocks of memory can be reused
    // This is incremented on each reuse
    uint64_t reuse_count = 0;

    // The data in this block
    uint8_t data[];

    // Delete the copy and move constructors
    // (if the copy constructors are deleted, no move constructors will be autogenerated)
    shm_block()                  = default;
    shm_block(const shm_block &) = delete;
    shm_block &operator=(const shm_block &) = delete;
};

// Get an shm key from a UUID
std::string get_key_from_uuid(const boost::uuids::uuid &uuid)
{
    return "neuropod." + boost::uuids::to_string(uuid);
}

// Used to generate UUIDs for blocks of memory
// `thread_local` so we can avoid locking
thread_local boost::uuids::random_generator uuid_generator;

// A unique ID for a SHM block
// Since blocks of memory can be reused, the UUID used to load
// the block isn't enough. An additional `reuse_count` field is
// used to detect when stale IDs are used and throw an error.
struct __attribute__((__packed__)) shm_block_id
{
    boost::uuids::uuid uuid;
    uint64_t           reuse_count;
};

// Make sure the size of the ID struct matches the size of the user facing version
static_assert(sizeof(shm_block_id) == std::tuple_size<SHMBlockID>::value,
              "The size of shm_block_id must match the size of SHMBlockID");

// Controls a block of shared memory
class SHMBlock
{
private:
    std::unique_ptr<ipc::shared_memory_object> shm_;
    std::unique_ptr<ipc::mapped_region>        region_;

    // A pointer to the struct in shared memory
    shm_block *block_;

    // The block's UUID
    boost::uuids::uuid uuid_;

public:
    // Allocate a new block of shared memory
    SHMBlock(size_t size_bytes)
        // Generate a UUID
        : uuid_(uuid_generator())
    {
        // Create a block of shared memory
        shm_ = stdx::make_unique<ipc::shared_memory_object>(
            ipc::create_only, get_key_from_uuid(uuid_).c_str(), ipc::read_write);

        // Set the size
        shm_->truncate(sizeof(shm_block) + size_bytes);

        // Map into memory
        region_ = stdx::make_unique<ipc::mapped_region>(*shm_, ipc::read_write);

        // Get a pointer to the struct and initialize it
        block_ = new (region_->get_address()) shm_block;

        // Increment the refcount
        // Note: we don't need to lock the mutex here because this is a brand new instance
        // and we are the only ones with a reference to it
        block_->process_refcount++;
    }

    // Load an existing block of shared memory from an ID
    SHMBlock(const shm_block_id *block_id)
    {
        // Extract the UUID
        uuid_ = block_id->uuid;

        // Extract the expected reuse count
        const uint64_t expected_reuse_count = block_id->reuse_count;

        // Load a chunk of shared memory
        shm_ = stdx::make_unique<ipc::shared_memory_object>(
            ipc::open_only, get_key_from_uuid(uuid_).c_str(), ipc::read_write);

        // Map into memory
        region_ = stdx::make_unique<ipc::mapped_region>(*shm_, ipc::read_write);

        // Get a pointer to the struct
        block_ = static_cast<shm_block *>(region_->get_address());

        // Lock the mutex
        ipc::scoped_lock<ipc::interprocess_mutex> lock(block_->mutex);

        // Sanity check
        if (block_->process_refcount == 0)
        {
            // This means that the other process isn't keeping references to data long enough for this
            // process to load the data.
            // This can lead to some hard to debug race conditions so we always throw an error.
            NEUROPOD_ERROR(
                "Tried getting a pointer to an existing chunk of memory that has a refcount of zero: " << uuid_);
        }

        // Make sure the `reuse_count` matches what we expect
        if (expected_reuse_count != block_->reuse_count)
        {
            // This means that the other process isn't keeping references to data long enough for this
            // process to load the data.
            // (A block of memory went out of scope and was reused before it could be loaded by the other process)
            NEUROPOD_ERROR("Tried loading a block of memory that went out of scope in the creating process. "
                           "Ensure that blocks of SHM stay in scope until they are loaded by the receiving process. "
                           "UUID: "
                           << uuid_ << ". Reuse count: " << block_->reuse_count
                           << ". Expected reuse count: " << expected_reuse_count);
        }

        // Increment the refcount
        block_->process_refcount++;
    }

    // Delete copy constructors
    SHMBlock(const SHMBlock &) = delete;
    SHMBlock &operator=(const SHMBlock &) = delete;

    ~SHMBlock()
    {
        ipc::scoped_lock<ipc::interprocess_mutex> lock(block_->mutex);

        // Decrement the refcount
        block_->process_refcount--;

        if (block_->process_refcount == 0)
        {
            // This block is unused!
            // Since the refcount is zero, that means no other process has a reference to it
            // Also, since this is the destructor, the object is being deleted so nothing
            // else in this process has a reference to it

            // Get the shm_key
            const auto shm_key = get_key_from_uuid(uuid_);

            // Unlock the scoped lock before we actually delete
            // This is safe because we're the only one with a reference to this block
            lock.unlock();

            // Unmap memory
            region_ = nullptr;
            shm_    = nullptr;

            // Free the shared memory
            if (!ipc::shared_memory_object::remove(shm_key.c_str()))
            {
                // We shouldn't throw errors from the destructor so let's just
                // log instead
                std::cerr << "Error freeing shared memory with key " << shm_key;
            }
        }
    }

    // Whether or not this block is used in another process
    bool claim_if_unused()
    {
        ipc::scoped_lock<ipc::interprocess_mutex> lock(block_->mutex);
        if (block_->process_refcount == 1)
        {
            // The refcount is one so this block is not used by any other processes.
            // Increase the reuse_count so that stale IDs will no longer work
            block_->reuse_count++;
            return true;
        }

        return false;
    }

    // Get a pointer to the data stored in shared memory
    void *get_data() { return block_->data; }

    shm_block_id get_id() const
    {
        ipc::scoped_lock<ipc::interprocess_mutex> lock(block_->mutex);
        return {uuid_, block_->reuse_count};
    }
};

} // namespace

class UnusedPool
{
private:
    // A pool of objects that the current process has allocated
    // which are currently not referenced in this process
    // These may be reused instead of allocating a new block of memory
    // if they are not used in other processes as well
    std::unordered_multimap<size_t, std::shared_ptr<SHMBlock>> unused_pool_;
    std::mutex                                                 unused_pool_mutex_;

public:
    // Look for an unused block that we have previously allocated that is of size
    // `size_bytes`. Return the block if found otherwise return nullptr
    std::shared_ptr<SHMBlock> maybe_get_existing_block(size_t size_bytes)
    {
        std::lock_guard<std::mutex> lock(unused_pool_mutex_);
        auto                        range = unused_pool_.equal_range(size_bytes);
        for (auto it = range.first; it != range.second; it++)
        {
            auto block = it->second;

            if (block->claim_if_unused())
            {
                // If we successfully claimed this block, remove it from the unused
                // pool and return it
                unused_pool_.erase(it);
                return block;
            }
        }

        return nullptr;
    }

    void add(size_t size_bytes, std::shared_ptr<SHMBlock> block)
    {
        std::lock_guard<std::mutex> lock(unused_pool_mutex_);
        unused_pool_.insert(std::make_pair(size_bytes, block));
    }

    void clear()
    {
        std::lock_guard<std::mutex> lock(unused_pool_mutex_);
        unused_pool_.clear();
    }
};

SHMAllocator::SHMAllocator() : unused_pool_(stdx::make_unique<UnusedPool>()) {}

SHMAllocator::~SHMAllocator() = default;

std::shared_ptr<void> SHMAllocator::allocate_shm(size_t size_bytes, SHMBlockID &block_id)
{
    // Try to get an existing unused block of the requested size
    auto block = unused_pool_->maybe_get_existing_block(size_bytes);

    // Othewise allocate a new one
    if (!block)
    {
        block = std::make_shared<SHMBlock>(size_bytes);
    }

    // Create a shared pointer to the underlying data with a custom deleter
    // that adds it to the unused pool
    std::shared_ptr<void> out(block->get_data(), [this, size_bytes, block](void *unused) {
        // This tensor was created by the current process and it is unused in the current process
        // Add it to our unused pool to potentially be reused (once it's no longer used in other
        // processes)
        unused_pool_->add(size_bytes, block);
    });

    // Return the ID of this block as well
    auto id = block->get_id();
    memcpy(block_id.data(), &id, sizeof(id));

    return out;
}

std::shared_ptr<void> SHMAllocator::load_shm(const SHMBlockID &block_id)
{
    // Load an existing block of shared memory by ID
    auto block = std::make_shared<SHMBlock>(reinterpret_cast<const shm_block_id *>(block_id.data()));

    // Create a shared pointer to the underlying data with a custom deleter
    // that keeps the block alive
    return std::shared_ptr<void>(block->get_data(), [block](void *unused) {});
}

void SHMAllocator::free_unused_shm_blocks()
{
    // Free all currently unused blocks that were allocated by this process
    unused_pool_->clear();
}

} // namespace neuropods
